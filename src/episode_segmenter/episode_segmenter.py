import datetime

from typing_extensions import List, Optional, Dict

from pycram.ros.logging import logwarn
from pycrap import Supporter
from .episode_player import EpisodePlayer
from .event_detectors import *
from .event_logger import EventLogger
from .events import *
from .object_tracker import ObjectTracker
from .utils import check_if_object_is_supported, Imaginator


class EpisodeSegmenter(ABC):

    def __init__(self, episode_player: EpisodePlayer,
                 detectors_to_start: Optional[List[Type[DetectorWithStarterEvent]]] = None,
                 annotate_events: bool = False):
        """
        Initializes the EpisodeSegmenter class.

        :param episode_player: The thread that plays the episode and generates the motion.
        :param detectors_to_start: The list of event detectors that should be started.
        :param annotate_events: A boolean value that indicates if the events should be annotated.
        """
        self.episode_player: EpisodePlayer = episode_player
        self.detectors_to_start: List[Type[DetectorWithStarterEvent]] = detectors_to_start
        self.logger = EventLogger(annotate_events, [PickUpEvent, PlacingEvent])
        self.objects_to_avoid = ['particle', 'floor', 'kitchen']  # TODO: Make it a function, to be more general
        self.tracked_object_contacts: Dict[Object, List[Type[AbstractContactDetector]]] = {}
        self.starter_event_to_detector_thread_map: [Event, Type[DetectorWithStarterEvent]] = {}
        self.detector_threads_list: List[EventDetectorUnion] = []
        self.object_trackers: Dict[Object, ObjectTracker] = {}

    def start(self) -> None:
        """
        Start the episode player and the event detectors.
        """
        self.start_episode_player_and_wait_till_ready()
        self.run_event_detectors()

    def start_episode_player_and_wait_till_ready(self) -> None:
        """
        Start the Episode player thread, and waits until the thread signals that it is
        ready (e.g., the replay environment is initialized with all objects in starting poses).
        """
        self.episode_player.start()
        while not self.episode_player.ready:
            time.sleep(0.1)

    def run_event_detectors(self) -> None:
        """
        Run the event detectors on the motion generated by the motion generator thread.
        """
        self.start_and_add_detector_thread(NewObjectDetector, avoid_objects=self.objects_to_avoid)
        self.run_initial_event_detectors()
        closed_threads = False

        while (not closed_threads) or (self.logger.event_queue.unfinished_tasks > 0):
            if not self.episode_player.is_alive() and not closed_threads:
                self.episode_player.join()

                for detector_thread in self.detector_threads_list:
                    detector_thread.stop()
                    logdebug(f"Joining {detector_thread.thread_id}, {detector_thread.name}")
                    detector_thread.join()
                closed_threads = True

            next_event = self.logger.get_next_event()

            if next_event is None:
                time.sleep(0.01)
                continue

            self.process_event(next_event)

        self.logger.plot_events()

        self.join()

    def process_event(self, event: EventUnion) -> None:
        """
        Process the event generated by the event logger, and start the detector threads that are triggered by the event.

        :param event: The event that should be processed.
        """
        self._process_event(event)
        self.start_triggered_detectors(event)

    def start_triggered_detectors(self, event: EventUnion) -> None:
        """
        Start the detector threads that are triggered by the event.

        :param event: The event that triggers the detector threads.
        """
        for event_detector in self.detectors_to_start:
            if event_detector.start_condition_checker(event):
                self.start_detector_thread_for_starter_event(event, event_detector)

    @abstractmethod
    def _process_event(self, event: Event) -> None:
        """
        Process the event generated by the event logger.

        :param event: The event that should be processed.
        """
        pass

    @abstractmethod
    def run_initial_event_detectors(self) -> None:
        """
        Run the initial event detectors on the episode played by the episode player thread.
        """
        pass

    def update_tracked_objects(self, event: EventUnion) -> None:
        """
        Update the tracked objects based on the event, for example a contact event would reveal new objects that should
        be tracked when an already tracked object comes into contact with a new object.

        :param event: The event that was triggered.
        """
        involved_objects = self.get_involved_objects(event)
        logdebug(f"Involved objects: {[obj.name for obj in involved_objects]}")
        for obj in involved_objects:
            if self.avoid_object(obj):
                continue
            if obj not in self.object_trackers.keys():
                logdebug(f"New object {obj.name}")
                self.object_trackers[obj] = ObjectTracker(obj)
                self.start_tracking_threads_for_new_object_and_event(obj, event)

    @abstractmethod
    def start_tracking_threads_for_new_object_and_event(self, new_object: Object, event: EventUnion):
        """
        Start the tracking threads for the new object, these threads are used to track the object's motion or contacts
         for example.

        :param new_object: The new object that should be tracked.
        :param event: The event that triggered the tracking.
        """
        pass

    def get_involved_objects(self, event: EventUnion) -> List[Object]:
        """
        Get the objects involved in the event.

        :param event: The event that involves the objects.
        :return: A list of Object instances that are involved in the event.
        """
        if isinstance(event, EventWithTrackedObjects):
            return event.involved_objects

    def avoid_object(self, obj: Object) -> bool:
        """
        Check if the object should be avoided.

        :param obj: The object to check.
        :return: True if the object should be avoided, False otherwise.
        """
        return obj.is_an_environment or issubclass(obj.obj_type, Supporter) or \
            any([k in obj.name.lower() for k in self.objects_to_avoid])

    def start_motion_detection_threads_for_object(self, obj: Object, event: Optional[NewObjectEvent] = None) -> None:
        """
        Start the motion detection threads for the object.

        :param obj: The Object instance for which the motion detection threads are started.
        :param event: The NewObjectEvent instance that represents the creation of the object.
        """
        if event is None:
            event = NewObjectEvent(obj)
        self.start_and_add_detector_thread(TranslationDetector, starter_event=event,
                                           time_between_frames=self.time_between_frames)
        self.start_and_add_detector_thread(RotationDetector, starter_event=event,
                                           time_between_frames=self.time_between_frames)

    def start_contact_threads_for_object(self, obj: Object,
                                         event: Optional[ContactEvent] = None) -> None:
        """
        Start the contact threads for the object and updates the tracked objects.

        :param obj: The Object instance for which the contact threads are started.
        :param event: The ContactEvent instance that represents the contact event with the object.
        """
        if event is None:
            if issubclass(obj.obj_type, pycrap.Agent):
                event = AgentContactEvent(ContactPointsList([]), obj)
            else:
                event = ContactEvent(ContactPointsList([]), obj)
        for detector in (ContactDetector, LossOfContactDetector):
            self.start_and_add_detector_thread(detector, starter_event=event)
        self.tracked_object_contacts[obj] = [ContactDetector, LossOfContactDetector]

    def start_detector_thread_for_starter_event(self, starter_event: EventUnion,
                                                detector_type: TypeEventDetectorUnion):
        """
        Start the detector thread for the given starter event.

        :param starter_event: The event that starts the detector thread.
        :param detector_type: The type of the detector.
        """
        if not self.is_detector_redundant(detector_type, starter_event):
            if detector_type == PlacingDetector:
                logdebug(f"new placing detector for object {starter_event.tracked_object.name}")
            self.start_and_add_detector_thread(detector_type, starter_event=starter_event)

    def is_detector_redundant(self, detector_type: TypeEventDetectorUnion, starter_event: EventUnion) -> bool:
        """
        Check if the detector is redundant.

        :param detector_type: The type of the detector.
        :param starter_event: The event that starts the detector thread.
        :return: True if the detector is redundant, False otherwise.
        """
        if (starter_event, detector_type) in self.starter_event_to_detector_thread_map.keys():
            detector = self.starter_event_to_detector_thread_map[(starter_event, detector_type)]
            if detector.is_alive() or (detector.detected_before and detector.run_once):
                return True
        return False

    def start_and_add_detector_thread(self, detector_type: TypeEventDetectorUnion,
                                      starter_event: Optional[EventUnion] = None,
                                      *detector_args, **detector_kwargs) -> None:
        """
        Start and add an event detector to the detector threads.

        :param detector_type: The event detector to be started and added.
        :param starter_event: The event that starts the detector thread.
        :param detector_args: The positional arguments to be passed to the detector constructor.
        :param detector_kwargs: The keyword arguments to be passed to the detector constructor.
        """
        tracked_object = None
        if starter_event is not None and isinstance(starter_event, (EventWithOneTrackedObject,
                                                                    EventWithTwoTrackedObjects)):
            tracked_object = starter_event.tracked_object
        if issubclass(detector_type, (DetectorWithTrackedObject, DetectorWithTwoTrackedObjects)):
            detector_args = [tracked_object] + list(detector_args)
        if issubclass(detector_type, DetectorWithStarterEvent):
            detector_args = [starter_event] + list(detector_args)
        detector = detector_type(self.logger, *detector_args, **detector_kwargs)
        detector.start()
        self.detector_threads_list.append(detector)
        logdebug(f"Created {detector_type.__name__}")
        if starter_event is not None:
            # self.starter_event_to_detector_thread_map[(starter_event, detector_type)] = detector
            logdebug(f"For starter event {starter_event}")

    @property
    def time_between_frames(self) -> datetime.timedelta:
        """
        :return: The time between frames of the episode player.
        """
        return self.episode_player.time_between_frames

    def join(self):
        """
        Join all the threads.
        """
        self.logger.print_events()
        self.logger.join()
        logdebug("All threads joined.")


class AgentBasedEpisodeSegmenter(EpisodeSegmenter):
    """
    The AgentBasedEpisodeSegmenter class is used to segment motions into activities (e.g. PickUp) by tracking the
     events that are relevant to the agent for example contact events of the hands or robot.
    """

    def start_tracking_threads_for_new_object_and_event(self, new_object: Object, event: Optional[ContactEvent] = None):
        logdebug(f"Creating contact and motion threads for object {new_object.name}")
        self.start_contact_threads_for_object(new_object, event)
        self.start_motion_detection_threads_for_object(new_object, event)

    # def get_involved_objects(self, event: ContactEvent) -> List[Object]:
    #     return event.contact_points.get_objects_that_have_points()

    def _process_event(self, event: Event) -> None:
        if isinstance(event, ContactEvent):
            self.update_tracked_objects(event)

    def run_initial_event_detectors(self) -> None:
        """
        Start the contact threads for the agents.
        """
        agents = self.get_agents()
        for agent in agents:
            self.start_contact_threads_for_object(agent)

    @staticmethod
    def get_agents() -> List[Object]:
        """
        :return: A list of Object instances that represent the available agents in the world.
        """
        return [obj for obj in World.current_world.objects if issubclass(obj.obj_type, pycrap.Agent)]


class NoAgentEpisodeSegmenter(EpisodeSegmenter):
    """
    The NoAgentEpisodeSegmenter class is used to segment episodes into activities (e.g. PickUp) by tracking the
     events that are relevant to the objects in the world with the lack of an agent in the episode.
    """

    def __init__(self, episode_player: EpisodePlayer,
                 detectors_to_start: Optional[List[Type[DetectorWithStarterEvent]]] = None,
                 annotate_events: bool = False):
        if detectors_to_start is None:
            detectors_to_start = [MotionPickUpDetector, PlacingDetector]
        super().__init__(episode_player, detectors_to_start=detectors_to_start, annotate_events=annotate_events)

    def start_tracking_threads_for_new_object_and_event(self, new_object: Object, event: EventUnion):
        pass

    def get_involved_objects(self, event: EventUnion) -> List[Object]:
        return []

    def _process_event(self, event: EventUnion) -> None:
        pass

    def run_initial_event_detectors(self) -> None:
        """
        Start the motion detection threads for the objects in the world.
        """
        set_of_objects = set()
        for obj in World.current_world.objects:
            if not self.avoid_object(obj):
                set_of_objects.add(obj)
                try:
                    if not check_if_object_is_supported(obj):
                        print(f"Object {obj.name} is not supported.")
                        Imaginator.imagine_support_for_object(obj)
                        print(f"Imagined support for object {obj.name}.")
                except NotImplementedError:
                    logwarn("Support detection is not implemented for this simulator.")
        for obj in set_of_objects:
            self.start_motion_detection_threads_for_object(obj)
            self.start_contact_threads_for_object(obj)
        self.episode_player.resume()
